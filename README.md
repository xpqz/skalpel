# Skalpel APL-alike

I wanted to implement an APL interpreter as the next phase of my [APL journey](https://xpqz.github.io/learnapl). I'm not arrogant enough to think that I somehow can do "better" than the incumbents; instead tackling this solely for my own amusement and as a means to gain insight into how things actually hang together 'under the hood'.

It's a work in progress, and lacking huge swathes of central chunks of what makes APL APL.

## So is it like an open-source version of Dyalog?

LOL. 

## But why?

The general advice to someone wanting to make their own programming language is typically [don't](https://blog.dhsdevelopments.com/dont-write-a-programming-language). If you want to make your own _array_ language, you need [special permission](https://ngn.codeberg.page/funny/reg.html) from the Ministry of Vector Processing. But here we are.

## Python?

It's slow, right? Undeniably, but fast enough for this exercise. 

## Prior art

There are actually quite a few open source APL-alikes around, and the intrepid neophyte APL implementer would do well to learn from them. Here's an abridged resource list:

* [APL in R](https://bookdown.org/jandeleeuw6/apl/core.html)
* [april](https://github.com/phantomics/april)
* [BQN](https://github.com/dzaima/CBQN)
* [dzaima/apl](https://github.com/dzaima/APL)
* [gnu/apl](https://www.gnu.org/software/apl/)
* [ivy](https://github.com/robpike/ivy)
* [kap](https://github.com/lokedhs/array)
* [ngn/apl](https://github.com/abrudz/ngn-apl)
* [RGS/apl](https://mathspp.com/blog/lsbasi-apl-part1)

## Install

If you really want to go there, you'll need [poetry](https://python-poetry.org/). You also need a bang-up-to-date version of Python (I use 3.10). At the moment, it only has one dependency, [bitarray](https://pypi.org/project/bitarray/). `skalpel` is type-annotated.

1. `git clone git@github.com:xpqz/skalpel.git`
2. `cd skalpel; poetry install; poetry shell`
3. `python apl/repl.py`

## Repl

The repl behaves like a typical `readline()` unixy repl thing, rather than the Dyalog APL repl. Quit with C-d. Step through history with arrows. It has some basic introspection capabilities, mainly for my own use when debugging. Starting a line with `]py ` will show the internal representation of the evaluated expression. `]cmpx "expr1" "expr2"` will compare the execution times of the two expressions similar to what Dyalog's [cmpx](https://dfns.dyalog.com/n_cmpx.htm) does. Skalpel is a bytecode compiler, not a tree-walking interpreter. Even in the repl, it parses, emits bytecode and then interprets this. You can inspect the generated bytecode using the `]compile ` command in the repl.

## Differences

`skalpel` makes a few concessions to the established APL grammar in order to make it context-free, along the lines of what [BQN](https://mlochbaum.github.io/BQN/spec/grammar.html) does, most crucially, requiring that function names must start with a capital letter:

```apl
Add ← {⍺+⍵} ⍝ right
add ← {⍺+⍵} ⍝ wrong
```

When `skalpel` eventually grows direct operator support, it will adopt BQN's naming approach there, too. 

## What's implemented so far?

Current built-ins can be seen in the file [skalpel.py](https://github.com/xpqz/skalpel/blob/main/apl/skalpel.py) in the `Voc` class towards the bottom. Basic support for dfns (no guards yet, and only local scope). Barely any operators (currently `/⌿¨⍥⍨`). Only numeric arrays!

## Are there tests? 

As a matter of fact, yes. We use `pytest` for unit tests, so you need that if you intend to run them. Tests are found in the suitably named `tests` directory. There is also the file `t.py` which runs the test suite for `ngn/apl`. At the moment, it only passes a minute fraction of those (about 10%), but it's aspirational. Many of the source files also contain doctests.
